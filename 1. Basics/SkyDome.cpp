#include "precomp.h"
#include "SkyDome.h"

SkyDome::SkyDome(FloatTexture* setTexture)
	: m_texture(setTexture)
{
	//Calc luminance
	const int pixelAmount = m_texture->m_resolution.x * m_texture->m_resolution.y;
	m_invpdf = new float[pixelAmount];
	m_cdf = new float[pixelAmount];
	float totalLumen = 0;
	int i = 0;
	for (int y = 0; y < m_texture->m_resolution.y; y++)
	{
		float v = (y + 0.5f) / m_texture->m_resolution.y;
		float theta = v * PI;
		float sinTheta = sin(theta);
		float pixelSolidAngle = (2.0f * PI / m_texture->m_resolution.x) * (PI / m_texture->m_resolution.y) * sinTheta;
		for (int x = 0; x < m_texture->m_resolution.x; x++)
		{
			float lumen = 0.2126f * m_texture->m_pixels[i].x + 0.7152f * m_texture->m_pixels[i].y + 0.0722f * m_texture
				->
				m_pixels[i]
				.z;
			lumen *= pixelSolidAngle;
			m_invpdf[i] = lumen;
			totalLumen += lumen;
			i++;
		}
	}

	//Calc pdf and cdf
	float totalCDF = 0;
	i = 0;
	for (int y = 0; y < m_texture->m_resolution.y; y++)
	{
		for (int x = 0; x < m_texture->m_resolution.x; x++)
		{
			float pdf = ((m_invpdf[i]) / totalLumen);
			//pdf = max(pdf, 0.001f);
			m_invpdf[i] = 1.f / pdf;
			totalCDF += pdf;
			m_cdf[i] = totalCDF;
			i++;
		}
	}
}

SkyDome::~SkyDome()
{
	delete m_texture;
}

uint SkyDome::GetImportancePixel(uint& _seed)
{
	float random = RandomFloat(_seed);
	const uint pixels = m_texture->m_resolution.x * m_texture->m_resolution.y;

	float* lower = std::lower_bound(m_cdf, m_cdf + pixels, random);

	// Get the index from the iterator
	uint index = uint(lower - m_cdf);

	return index;
}

//Generated by chatgpt
float3 SkyDome::PixelToDirection(uint _pixel)
{
	// Get the pixel coordinates in the texture
	int y = int(floor(_pixel / m_texture->m_resolution.x));
	int x = _pixel - y * m_texture->m_resolution.x;

	// Normalize pixel coordinates to [0, 1]
	float u = (x + 0.5f) / m_texture->m_resolution.x;
	float v = (y + 0.5f) / m_texture->m_resolution.y;

	// Convert texture coordinates (u, v) back to spherical coordinates (theta, phi)
	float phi = (u - 0.5f) * 2.0f * PI; // Azimuthal angle (phi) in [-PI, PI]
	float theta = (0.5f - v) * PI; // Polar angle (theta) in [0, PI]

	// Convert spherical coordinates (theta, phi) to 3D direction (dx, dy, dz)
	float sintheta = sin(theta);
	float costheta = cos(theta);
	float sinphi = sin(phi);
	float cosphi = cos(phi);

	// Convert to 3D direction vector
	auto direction = float3(sintheta * cosphi, costheta, sintheta * sinphi);
	return direction;
}

float4 SkyDome::sample(uint& _seed, float3& _outDirection)
{
	//Importance sample
	uint importantPixel = GetImportancePixel(_seed);
	float3 ray = normalize(PixelToDirection(importantPixel));

	float4 color = m_texture->SampleSphere(ray);
	color *= m_invpdf[importantPixel];
	color.w = 1.f;
	//if (length(color) > 50.f)
	//{
	//	printf("HUh");
	//}
	_outDirection = ray;
	return color;
}
